'@Namespace rLogM rLogMixin

' /**
'  * @member initializeLogManager
'  * @memberof module:LogMixin
'  * @instance
'  * @description creates Log manager, and places it on global
'  *              expects to have access to globalNode on m.global (i.e. from within an SG control)
'  *              to disable logging, simply never call initializeRLog - and your app will
'  *              not incur any logging costs beyond the initial method invocation
'  * @param {transportTypes} array of transportsType names.
'  *      you can provide your own transport;
'  *      it just hast to be a node that implements the interface function:
'  *
'  *      function logItem(name, levelNum, text) as void
'  *
'  *      built in transports:
'  *      LogNodeTransport - output goes straight to debug print
'  *      LogScreenTransport - output is stored on
'  *      LogPrintTransport - output goes to console
'  *
'  * @param {integer} logLevel
'  *                level of the logging
'  *                0 - ERROR
'  *                1 - WARN
'  *                2 - INFO and METHOD
'  *                3 - VERBOSE
'  *                4 - DEBUG 
'  * @returns {RLog} RLog instance for further configuration
'  */
function initializeLogManager(transportTypes = invalid, logLevel = invalid) as object
  rLog = CreateObject("roSGNode", "Log")
  m.global.addFields({ "rLog": rLog })

  if transportTypes = invalid
    transportTypes = ["LogPrintTransport"]
  end if

  if logLevel = invalid
    logLevel = 2
  end if

  rLog.transportTypes = transportTypes
  rLog.logLevel = logLevel
  return rLog
end function

' /**
'  * @member registerLogger
'  * @memberof module:LogMixin
'  * @instance
'  * @description registers this object (module/SGNode - whatever m is) as a logger
'  *              From that point on, you can call:
'  *              m.logError
'  *              m.logWarn
'  *              m.logInfo
'  *              m.logVerbose
'  *              m.logDebug
'  * @param {string} name of the logger - this can later be used in includeFilters and excludeFitlers
'  */
function registerLogger(name = "general", target = invalid) as void
  if target = invalid
    target = m
  end if
  target.rLog_name = name

  if target.rLog <> invalid
    return 
  end if

  target.rLog = getLogInstance()
  target.logImpl = function(levelNum, level, message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#", isMethod = false) as void
    if m.rLog = invalid then return
    if m.rLog_name <> invalid
      name = m.rLog_name
    else
      name = "General"
    end if

    if m.rLog.isFiltering
      if m.rLog.logLevel < levelNum or (m.rLog.includeFilters.count() > 0 and m.rLog.includeFilters[name] = invalid) or (m.rLog.excludeFilters.count() > 0 and m.rLog.excludeFilters[name] <> invalid)
        return 
      end if
    end if

    logMode = m.rLog.logMode
    if logMode = 1
      print level ; " " ; toString(message) ; " " ; toString(value) ; " " ; toString(value2) ; " " ; toString(value3) 
      print " " ; toString(value5) ; " " ; toString(value6) ; " " ; toString(value7) ; " " ; toString(value8) ; " " ; toString(value9) 
    else
      text = level + " " + toString(message) + " " + toString(value) + " " + toString(value2) + " " + toString(value3) + " " + toString(value4) + " " + toString(value5) + " " + toString(value6) + " " + toString(value7) + " " + toString(value8) + " " + toString(value9)

      if logMode = 3
        print text
      end if

      for each transport in m.rLog.transports
        transport.callFunc("logItem", name, levelNum, text)
      end for
    end if

  end function

  target.logDebug = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(4, "DEBUG", message, value, value2, value3, value4, value5, value6, value7, value8, value9)
  end function

  target.logVerbose = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(3, "VERBOSE", message, value, value2, value3, value4, value5, value6, value7, value8, value9)
  end function

  target.logInfo = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(2, "INFO", message, value, value2, value3, value4, value5, value6, value7, value8, value9)
  end function

  target.logMethod = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(2, "METHOD", message, value, value2, value3, value4, value5, value6, value7, value8, value9, true)
  end function

  target.logWarn = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(1, "WARN", message, value, value2, value3, value4, value5, value6, value7, value8, value9)
  end function

  target.logError = function(message, value = "~#", value2 = "~#", value3 = "~#", value4 = "~#", value5 = "~#", value6 = "~#", value7 = "~#", value8 = "~#", value9 = "~#") as void
    if m.rLog = invalid then return
    m.logImpl(0, "ERROR", message, value, value2, value3, value4, value5, value6, value7, value8, value9)
  end function
end function

function getLogInstance()
  if m.global <> invalid
    return m.global.rLog
  end if

  return invalid
end function

function toString(value as dynamic) as string
  valueType = type(value)
  if valueType = "<uninitialized>"
    return "UNINIT"
  else if value = invalid
    return "INVALID"
  else if GetInterface(value, "ifString") <> invalid
    if value = "~#"
      return ""
    else
      return value
    end if
  else if valueType = "roInt" or valueType = "roInteger" or valueType = "Integer"
    return value.tostr()
  else if GetInterface(value, "ifFloat") <> invalid
    return Str(value).Trim()
  else if valueType = "roSGNode"
    return "Node(" + value.subType() + ")"
  else if valueType = "roAssociativeArray"
    return "AA(" + formatJson(value) + ")"
  else if valueType = "roBoolean" or valueType = "Boolean"
    return value.tostr()
  else
    return ""
  end if
end function